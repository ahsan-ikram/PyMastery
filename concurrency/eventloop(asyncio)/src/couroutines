import asyncio

"""
This module demonstrates coroutine type annotations.

Although calling an `async def` function produces a coroutine object,
the recommended return annotation is the *awaited result*, not the
coroutine object itself. For example:

    async def worker() -> None:
        ...

Here, `-> None` indicates that awaiting the coroutine yields no value.
This is clearer and more idiomatic than writing:

    async def worker() -> Coroutine[Any, Any, None]:
        ...

Both forms are technically valid, but `-> None` (or `-> T` for a value)
is preferred because:

- It communicates the *result of awaiting* the coroutine, which is what
  most readers and type checkers care about.
- It avoids verbose `Coroutine[...]` signatures except in advanced
  library code where the coroutine object itself is manipulated.
- It aligns with community practice and improves readability.

In short: use `-> None` (or `-> T`) to describe what the coroutine
returns when awaited, rather than the raw coroutine object.
"""


async def couroutine_iterator() -> None:
    """
    Any function defined with 'async def' is a coroutine.
    Coroutines are special functions that can pause and resume their execution.
    They are the building blocks of asynchronous programming in Python.
    The return type of a coroutine is a coroutine object.
    Event loop is responsible for managing and executing these coroutines.

    Args:
        None: No arguments.

    Returns:
        None: No return value.

    """
    print("Couroutine started ...")
    for i in range(5):
        print(f"Couroutine working on iteration {i}")
        # This 5 seconds sleep simulates an I/O-bound operation
        # Other tasks can run while this coroutine is waiting
        await asyncio.sleep(5)
    print("Couroutine ended!")


asyncio.run(couroutine_iterator())
